"""
Kerberos Version 5 Protocol

- Edited by b3kc4t to using stated references on kerberosv5 file.
References = https://github.com/SecureAuthCorp/impacket, https://docs.microsoft.com/en-us/windows-server/security/kerberos/kerberos-authentication-overview

"""

import datetime
import random
import socket
import struct
import os,sys
import logging
from pyasn1.codec.der import decoder, encoder
from pyasn1.error import PyAsn1Error
from pyasn1.type.univ import noValue, Sequence
from pyasn1.type.useful import GeneralizedTime
from six import b
from binascii import unhexlify, hexlify

from pentestui.pentest_api.attacks.kerberos.modules.krb5.asn1 import AS_REQ, AP_REQ, TGS_REQ, KERB_PA_PAC_REQUEST, KRB_ERROR, PA_ENC_TS_ENC, AS_REP, TGS_REP, \
    EncryptedData, Authenticator, EncASRepPart, EncTGSRepPart, seq_set, seq_set_iter, KERB_ERROR_DATA, METHOD_DATA, \
    ETYPE_INFO2, ETYPE_INFO, AP_REP, EncAPRepPart
from pentestui.pentest_api.attacks.kerberos.modules.krb5.types import KerberosTime, Principal, Ticket
from pentestui.pentest_api.attacks.kerberos.modules.krb5.gssapi import CheckSumField, GSS_C_DCE_STYLE, GSS_C_MUTUAL_FLAG, GSS_C_REPLAY_FLAG, \
    GSS_C_SEQUENCE_FLAG, GSS_C_CONF_FLAG, GSS_C_INTEG_FLAG
from pentestui.pentest_api.attacks.kerberos.modules.krb5 import constants
from pentestui.pentest_api.attacks.kerberos.modules.krb5.crypto import Key, _enctype_table, InvalidChecksum
from pentestui.pentest_api.attacks.kerberos.modules.smbconnection import SessionError
from pentestui.pentest_api.attacks.kerberos.modules.spnego import SPNEGO_NegTokenInit, TypesMech, SPNEGO_NegTokenResp, ASN1_OID, asn1encode, ASN1_AID
from pentestui.pentest_api.attacks.kerberos.modules.krb5.gssapi import KRB5_AP_REQ
from pentestui.pentest_api.attacks.kerberos.modules import nt_errors
from pentestui.pentest_api.attacks.kerberos.modules.krb5.ccache import CCache
from pentestui.pentest_api.attacks.kerberos.modules.krb5.kerberosoutput import KerberosTGTHash
from pentestui.pentest_api.attacks.kerberos.modules.krb5.v5Error import ErrorKerb

try:
    rand = random.SystemRandom()
except NotImplementedError:
    rand = random
    pass

def sendReceive(data, host, kdcHost):
    """ Receiveing D """
    targetHost = kdcHost
    messageLength = struct.pack('!i', len(data))

    # Connect Kerberos Protocol on target Host with Socket
    try:
        af, socktype, proto, canonname, sa = socket.getaddrinfo(targetHost, 88, 0, socket.SOCK_STREAM)[0]
        s = socket.socket(af, socktype, proto)
        s.connect(sa)
    except socket.error as e:
        ErrorKerb.kerberosProtocolConnError(e)

    # Send message
    s.sendall(messageLength + data)
    recvDataLength = struct.unpack('!i', s.recv(4))[0]

    r = s.recv(recvDataLength)
    # Adjust Receiving Data length
    while len(r) < recvDataLength:
        r += s.recv(recvDataLength - len(r))

    try:
        krbError = KerberosError(packet = decoder.decode(r, asn1Spec = KRB_ERROR())[0])
    except:
        return r

    if krbError.getErrorCode() != constants.ErrorCodes.KDC_ERR_PREAUTH_REQUIRED.value:
        try:
            for i in decoder.decode(r):
                if type(i) == Sequence:
                    for k in vars(i)["_componentValues"]:
                        if type(k) == GeneralizedTime:
                            # UTF - 8
                            server_time = datetime.datetime.strptime(k.asOctets().decode("utf-8"), "%Y%m%d%H%M%SZ")
        except:
            KerberosError.TimeOfServer()


    return r

class KerberosError(SessionError, ErrorKerb):
    """
    Kerberos Error Part
    """
    def __init__( self, error = 0, packet=0):
        SessionError.__init__(self)
        self.error = error
        self.packet = packet
        if packet != 0:
            self.error = self.packet['error-code']

    def getErrorCode(self):
        return self.error
    def getErrorPacket(self):
        return self.kerberosPacketError(self.packet)
    def getErrorString(self):
        return self.kerberosKDCError(constants.ERROR_MESSAGES[self.error])
    def getErrorStrngGeneric(self):
        if self.error == constants.ErrorCodes.KRB_ERR_GENERIC.value:
            ErrorCode = constants.ErrorCodes.KRB_ERR_GENERIC.value
            self.kerberosKRBGeneric(constants.ERROR_MESSAGES[ErrorCode])
    def PreAuthError(preError):
        ErrorKerb.kerberosPreError(preError)

    def NotSupportEncType(encError):
        ErrorKerb.kdcEncError(encError)

    def SessionKeyError(errorSesMsg):
        ErrorKerb.SessionKeyDecryption(errorSesMsg)

    def TimeOfServer():
        ErrorKerb.timeOServer()





def getKerberosTGT(clientName, password, domain, lmhash, nthash, aesKey='', kdcHost=None, requestPAC=True):
    """ Kerberos TGT request with PAC """
    # Authentication Server Request
    asReq = AS_REQ()

    domain = domain.upper()
    serverName = Principal('krbtgt/%s'%domain, type=constants.PrincipalNameType.NT_PRINCIPAL.value)

    # Pac Object
    pacRequest = KERB_PA_PAC_REQUEST()
    pacRequest['include-pac'] = requestPAC
    # Sign And cipher from Pac
    encodedPacRequest = encoder.encode(pacRequest)

    asReq['pvno'] = 5
    asReq['msg-type'] =  int(constants.ApplicationTagNumbers.AS_REQ.value)

    asReq['padata'] = noValue
    asReq['padata'][0] = noValue
    asReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_PAC_REQUEST.value)
    asReq['padata'][0]['padata-value'] = encodedPacRequest

    reqBody = seq_set(asReq, 'req-body')

    opts = list()
    opts.append( constants.KDCOptions.forwardable.value )
    opts.append( constants.KDCOptions.renewable.value )
    opts.append( constants.KDCOptions.proxiable.value )
    reqBody['kdc-options']  = constants.encodeFlags(opts)

    seq_set(reqBody, 'sname', serverName.components_to_asn1)
    seq_set(reqBody, 'cname', clientName.components_to_asn1)

    reqBody['realm'] = domain

    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)
    reqBody['till'] = KerberosTime.to_asn1(now)
    reqBody['rtime'] = KerberosTime.to_asn1(now)
    reqBody['nonce'] =  rand.getrandbits(31)

    # AES 256
    supportedCiphers = (int(constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value),)

    seq_set_iter(reqBody, 'etype', supportedCiphers)

    message = encoder.encode(asReq)

    try:
        r = sendReceive(message, domain, kdcHost)
    except:
        # if process not work try rc4 cipher type
        supportedCiphers = (int(constants.EncryptionTypes.rc4_hmac.value),)
        seq_set_iter(reqBody, 'etype', supportedCiphers)
        message = encoder.encode(asReq)
        r = sendReceive(message, domain, kdcHost)

    preAuth = True
    try:
        asRep = decoder.decode(r, asn1Spec = KRB_ERROR())[0]
    except:
        #
        asRep = decoder.decode(r, asn1Spec=AS_REP())[0]
        preAuth = False

    # Dictionary var (!)
    encryptionTypesData = dict()
    salt = ''
    if preAuth is False:
        methods = asRep['padata']
        encryptionTypesData[supportedCiphers[0]] = salt
        #
        tgt = r
    else:
        methods = decoder.decode(asRep['e-data'], asn1Spec=METHOD_DATA())[0]
    # Enc Data Method
    for method in methods:
        if method['padata-type'] == constants.PreAuthenticationDataTypes.PA_ETYPE_INFO2.value:
            etypes2 = decoder.decode(method['padata-value'], asn1Spec = ETYPE_INFO2())[0]
            for etype2 in etypes2:
                try:
                    if etype2['salt'] is None or etype2['salt'].hasValue() is False:
                        salt = ''
                    else:
                        salt = etype2['salt'].prettyPrint()
                except PyAsn1Error:
                    salt = ''

                encryptionTypesData[etype2['etype']] = b(salt)
        elif method['padata-type'] == constants.PreAuthenticationDataTypes.PA_ETYPE_INFO.value:
            etypes = decoder.decode(method['padata-value'], asn1Spec = ETYPE_INFO())[0]
            for etype in etypes:
                try:
                    if etype['salt'] is None or etype['salt'].hasValue() is False:
                        salt = ''
                    else:
                        salt = etype['salt'].prettyPrint()
                except PyAsn1Error:
                    salt = ''

                encryptionTypesData[etype['etype']] = b(salt)

    enctype = supportedCiphers[0]

    cipher = _enctype_table[enctype]
    # Key !
    key = cipher.string_to_key(password, encryptionTypesData[enctype], None)

    if preAuth is True:
        if enctype in encryptionTypesData is False:
            KerberosError.PreAuthError('No Encryption Data Available!')

        # TimeStamp Value From PAC
        timeStamp = PA_ENC_TS_ENC()
        now = datetime.datetime.utcnow()
        timeStamp['patimestamp'] = KerberosTime.to_asn1(now)
        timeStamp['pausec'] = now.microsecond

        # Encrypt the timestamp
        encodedTimeStamp = encoder.encode(timeStamp)

        # AS-REQ PA-ENC-TIMESTAMP padata timestamp with KEY
        encriptedTimeStamp = cipher.encrypt(key, 1, encodedTimeStamp, None)

        encryptedData = EncryptedData()
        encryptedData['etype'] = cipher.enctype
        encryptedData['cipher'] = encriptedTimeStamp
        encodedEncryptedData = encoder.encode(encryptedData)

        # AS_REQ again with the PADATA

        asReq = AS_REQ()

        asReq['pvno'] = 5
        asReq['msg-type'] =  int(constants.ApplicationTagNumbers.AS_REQ.value)

        asReq['padata'] = noValue
        asReq['padata'][0] = noValue
        asReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_ENC_TIMESTAMP.value)
        asReq['padata'][0]['padata-value'] = encodedEncryptedData

        asReq['padata'][1] = noValue
        asReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_PAC_REQUEST.value)
        asReq['padata'][1]['padata-value'] = encodedPacRequest

        reqBody = seq_set(asReq, 'req-body')

        opts = list()
        opts.append( constants.KDCOptions.forwardable.value )
        opts.append( constants.KDCOptions.renewable.value )
        opts.append( constants.KDCOptions.proxiable.value )
        reqBody['kdc-options'] = constants.encodeFlags(opts)

        seq_set(reqBody, 'sname', serverName.components_to_asn1)
        seq_set(reqBody, 'cname', clientName.components_to_asn1)

        reqBody['realm'] =  domain

        now = datetime.datetime.utcnow() + datetime.timedelta(days=1)
        reqBody['till'] = KerberosTime.to_asn1(now)
        reqBody['rtime'] =  KerberosTime.to_asn1(now)
        reqBody['nonce'] = rand.getrandbits(31)

        seq_set_iter(reqBody, 'etype', ( (int(cipher.enctype),)))

        try:
            tgt = sendReceive(encoder.encode(asReq), domain, kdcHost)
        except Exception as e:

            if str(e).find('KDC_ERR_ETYPE_NOSUPP') >= 0:
                # Not Support
                ErrorNameK = constants.ERROR_MESSAGES[14]
                KerberosError.NotSupportEncType(ErrorNameK)

        # Authentication Server Reply
        asRep = decoder.decode(tgt, asn1Spec = AS_REP())[0]

    # Extract SessionKey
    cipherText = asRep['enc-part']['cipher']

    if preAuth is False:
        # TGT enc-part/cipher in John format
        KerberosTGTHash.asRepHash()
        entry = '$krb5asrep$%d$%s@%s:%s$%s' % (asRep['enc-part']['etype'],clientName, domain, hexlify(asRep['enc-part']['cipher'].asOctets()[:16]),
                                           hexlify(asRep['enc-part']['cipher'].asOctets()[16:]))
        KerberosTGTHash.asRepHash(entry)


    #  Encrypted with the client key
    try:
        plainText = cipher.decrypt(key, 3, cipherText)
    except InvalidChecksum as e:
        # Check Session Key Error
        errorSesMsg = "failed to decrypt session key: %s" % str(e)
        KerberosError.SessionKeyError(errorSesMsg)

    # Encryption ASRep
    encASRepPart = decoder.decode(plainText, asn1Spec = EncASRepPart())[0]
    # Create Session Key
    cipher = _enctype_table[encASRepPart['key']['keytype']]
    sessionKey = Key(cipher.enctype,encASRepPart['key']['keyvalue'].asOctets())

    return tgt, cipher, key, sessionKey




def getKerberosTGS(serverName, domain, kdcHost, tgt, cipher, sessionKey):
    """ Kerberos Authentication TGS request with client TGT"""
    # Decode TGT
    try:
        decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]
    except:
        decodedTGT = decoder.decode(tgt, asn1Spec=TGS_REP())[0]

    domain = domain.upper()

    # Extract the ticket from the TGT
    ticket = Ticket()
    ticket.from_asn1(decodedTGT['ticket'])

    apReq = AP_REQ()
    apReq['pvno'] = 5
    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)

    opts = list()
    apReq['ap-options'] = constants.encodeFlags(opts)
    seq_set(apReq, 'ticket', ticket.to_asn1)

    # Authentication Part
    authenticator = Authenticator()
    authenticator['authenticator-vno'] = 5
    authenticator['crealm'] = decodedTGT['crealm'].asOctets()

    #
    clientName = Principal()
    clientName.from_asn1(decodedTGT, 'crealm', 'cname')

    seq_set(authenticator, 'cname', clientName.components_to_asn1)

    # Kerberos timestamp addition
    now = datetime.datetime.utcnow()
    authenticator['cusec'] = now.microsecond
    authenticator['ctime'] = KerberosTime.to_asn1(now)

    encodedAuthenticator = encoder.encode(authenticator)

    # TGS Request
    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)

    apReq['authenticator'] = noValue
    apReq['authenticator']['etype'] = cipher.enctype
    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator

    encodedApReq = encoder.encode(apReq)

    # TGS Request object and additional
    tgsReq = TGS_REQ()

    tgsReq['pvno'] = 5
    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)
    tgsReq['padata'] = noValue
    tgsReq['padata'][0] = noValue
    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)
    tgsReq['padata'][0]['padata-value'] = encodedApReq

    reqBody = seq_set(tgsReq, 'req-body')

    opts = list()
    opts.append(constants.KDCOptions.forwardable.value)
    opts.append(constants.KDCOptions.renewable.value)
    opts.append(constants.KDCOptions.renewable_ok.value)
    opts.append(constants.KDCOptions.canonicalize.value)

    reqBody['kdc-options'] = constants.encodeFlags(opts)
    seq_set(reqBody, 'sname', serverName.components_to_asn1)
    reqBody['realm'] = domain

    #TGS timestamp (For 1 day)
    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)

    reqBody['till'] = KerberosTime.to_asn1(now)
    reqBody['nonce'] = rand.getrandbits(31)

    seq_set_iter(reqBody, 'etype',
                       (
                            int(constants.EncryptionTypes.rc4_hmac.value),
                            int(constants.EncryptionTypes.des3_cbc_sha1_kd.value),
                            int(constants.EncryptionTypes.des_cbc_md5.value),
                            int(cipher.enctype)
                       )
                )
    message = encoder.encode(tgsReq)

    r = sendReceive(message, domain, kdcHost)

    # Session Key
    tgs = decoder.decode(r, asn1Spec = TGS_REP())[0]
    cipherText = tgs['enc-part']['cipher']


    ### TGS-REP REply From Ticket Granting ticket

    plainText = cipher.decrypt(sessionKey, 8, cipherText)
    encTGSRepPart = decoder.decode(plainText, asn1Spec = EncTGSRepPart())[0]

    newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'].asOctets())
    # New Cipher key
    cipher = _enctype_table[encTGSRepPart['key']['keytype']]

    res = decoder.decode(r, asn1Spec = TGS_REP())[0]
    spn = Principal()
    spn.from_asn1(res['ticket'], 'realm', 'sname')

    if spn.components[0] == serverName.components[0]:
        #
        return r, cipher, sessionKey, newSessionKey

    else:
        domain = spn.components[1]
        return getKerberosTGS(serverName, domain, kdcHost, r, cipher, newSessionKey)
